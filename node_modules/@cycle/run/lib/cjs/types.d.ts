import { Stream } from 'xstream';
export interface FantasyObserver {
    next(x: any): void;
    error(err: any): void;
    complete(c?: any): void;
}
export interface FantasySubscription {
    unsubscribe(): void;
}
export interface FantasyObservable {
    subscribe(observer: FantasyObserver): FantasySubscription;
}
export interface DevToolEnabledSource {
    _isCycleSource: string;
}
export declare type SinkProxies<Si> = {
    [P in keyof Si]: Stream<any>;
};
export declare type Driver<Si, So> = {
    (stream?: Si, driverName?: string): So;
};
export declare type DisposeFunction = () => void;
export declare type Drivers = {
    [name: string]: Driver<Stream<any> | void, any | void>;
};
export declare type Main = (...args: Array<any>) => any;
export declare type Sources<D extends Drivers> = {
    [k in keyof D]: ReturnType<D[k]>;
};
export declare type Sinks<M extends Main> = ReturnType<M>;
export declare type MatchingMain<D extends Drivers, M extends Main> = (Main & {
    (so: Sources<D>): Sinks<M>;
}) | (Main & {
    (): Sinks<M>;
});
export declare type MatchingDrivers<D extends Drivers, M extends Main> = Drivers & {
    [k in string & keyof Sinks<M>]: ((si?: Sinks<M>[k]) => Sources<D>[k]) | ((si: Sinks<M>[k]) => Sources<D>[k]);
};
export interface CycleProgram<D extends MatchingDrivers<D, M>, M extends MatchingMain<D, M>> {
    sources: Sources<D>;
    sinks: Sinks<M>;
    run(): DisposeFunction;
}
export interface Engine<D extends Drivers> {
    sources: Sources<D>;
    run<M extends MatchingMain<D, M>>(sinks: Sinks<M>): DisposeFunction;
    dispose(): void;
}
