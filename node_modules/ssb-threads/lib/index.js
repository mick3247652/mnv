"use strict";
var pull = require('pull-stream');
var cat = require('pull-cat');
var FlumeViewLevel = require('flumeview-level');
var sort = require('ssb-sort');
var ssbRef = require('ssb-ref');
var QuickLRU = require('quick-lru');
function getTimestamp(msg) {
    return msg.value.timestamp;
}
function getRootMsgId(msg) {
    if (msg && msg.value && msg.value.content) {
        var root = msg.value.content.root;
        if (ssbRef.isMsgId(root))
            return root;
    }
}
function buildPublicIndex(ssb) {
    return ssb._flumeUse('threads-public', FlumeViewLevel(1, function (msg, seq) { return [
        ['any', getTimestamp(msg), getRootMsgId(msg) || msg.key],
    ]; }));
}
function buildProfilesIndex(ssb) {
    return ssb._flumeUse('threads-profiles', FlumeViewLevel(1, function (msg, seq) { return [
        [msg.value.author, getTimestamp(msg), getRootMsgId(msg) || msg.key],
    ]; }));
}
function isValidIndexItem(item) {
    return !!item && !!item[2];
}
function isUnique(uniqueRoots) {
    return function checkIsUnique(item) {
        var rootKey = item[2];
        if (uniqueRoots.has(rootKey)) {
            return false;
        }
        else {
            uniqueRoots.add(rootKey);
            return true;
        }
    };
}
function isPublic(msg) {
    return !msg.value.content || typeof msg.value.content !== 'string';
}
function isNotMine(sbot) {
    return function isNotMineGivenSbot(msg) {
        return msg && msg.value && msg.value.author !== sbot.id;
    };
}
function materialize(sbot, cache) {
    function sbotGetWithCache(item, cb) {
        var authorId = item[0], timestamp = item[1], key = item[2];
        if (cache.has(key)) {
            cb(null, cache.get(key));
        }
        else {
            sbot.get(key, function (err, value) {
                if (err)
                    return cb(err);
                var msg = { key: key, value: value, timestamp: timestamp };
                if (msg.value)
                    cache.set(key, msg);
                cb(null, msg);
            });
        }
    }
    return function fetchMsg(item, cb) {
        sbotGetWithCache(item, function (err, msg) {
            if (err)
                return cb(err);
            cb(null, msg);
        });
    };
}
function makeWhitelistFilter(list) {
    return function (msg) {
        return !list ||
            (msg &&
                msg.value &&
                msg.value.content &&
                msg.value.content.type &&
                list.indexOf(msg.value.content.type) > -1);
    };
}
function makeBlacklistFilter(list) {
    return function (msg) {
        return !list ||
            !(msg &&
                msg.value &&
                msg.value.content &&
                msg.value.content.type &&
                list.indexOf(msg.value.content.type) > -1);
    };
}
function makeFilter(opts) {
    var passesWhitelist = makeWhitelistFilter(opts.whitelist);
    var passesBlacklist = makeBlacklistFilter(opts.blacklist);
    return function (m) { return passesWhitelist(m) && passesBlacklist(m); };
}
function rootToThread(sbot, threadMaxSize, filter) {
    return function (root, cb) {
        pull(cat([
            pull.values([root]),
            pull(sbot.backlinks.read({
                query: [{ $filter: { dest: root.key } }],
                index: 'DTA',
                live: false,
                reverse: true,
            }), pull.filter(filter), pull.take(threadMaxSize)),
        ]), pull.take(threadMaxSize + 1), pull.collect(function (err2, arr) {
            if (err2)
                return cb(err2);
            var full = arr.length <= threadMaxSize;
            sort(arr);
            if (arr.length > threadMaxSize && arr.length >= 3)
                arr.splice(1, 1);
            cb(null, { messages: arr, full: full });
        }));
    };
}
function init(ssb, config) {
    if (!ssb.backlinks || !ssb.backlinks.read) {
        throw new Error('"ssb-threads" is missing required plugin "ssb-backlinks"');
    }
    var publicIndex = buildPublicIndex(ssb);
    var profilesIndex = buildProfilesIndex(ssb);
    return {
        public: function _public(opts) {
            var lt = opts.lt;
            var reverse = opts.reverse === false ? false : true;
            var live = opts.live === true ? true : false;
            var maxThreads = opts.limit || Infinity;
            var threadMaxSize = opts.threadMaxSize || Infinity;
            var filter = makeFilter(opts);
            return pull(publicIndex.read({
                lt: ['any', lt, undefined],
                reverse: reverse,
                live: live,
                keys: true,
                values: false,
                seqs: false,
            }), pull.filter(isValidIndexItem), pull.filter(isUnique(new Set())), pull.asyncMap(materialize(ssb, new QuickLRU({ maxSize: 200 }))), pull.filter(isPublic), pull.filter(filter), pull.take(maxThreads), pull.asyncMap(rootToThread(ssb, threadMaxSize, filter)));
        },
        publicUpdates: function _publicUpdates(opts) {
            var filter = makeFilter(opts);
            return pull(ssb.createFeedStream({ reverse: false, old: false, live: true }), pull.filter(isNotMine(ssb)), pull.filter(isPublic), pull.filter(filter), pull.map(function (msg) { return msg.key; }));
        },
        profile: function _profile(opts) {
            var id = opts.id;
            var lt = opts.lt;
            var reverse = opts.reverse === false ? false : true;
            var live = opts.live === true ? true : false;
            var maxThreads = opts.limit || Infinity;
            var threadMaxSize = opts.threadMaxSize || Infinity;
            var filter = makeFilter(opts);
            return pull(profilesIndex.read({
                lt: [id, lt, undefined],
                gt: [id, null, undefined],
                reverse: reverse,
                live: live,
                keys: true,
                values: false,
                seqs: false,
            }), pull.filter(isValidIndexItem), pull.filter(isUnique(new Set())), pull.asyncMap(materialize(ssb, new QuickLRU({ maxSize: 200 }))), pull.filter(isPublic), pull.filter(filter), pull.take(maxThreads), pull.asyncMap(rootToThread(ssb, threadMaxSize, filter)));
        },
        thread: function _thread(opts) {
            var threadMaxSize = opts.threadMaxSize || Infinity;
            var rootToMsg = function (val) { return ({
                key: opts.root,
                value: val,
                timestamp: val.timestamp,
            }); };
            var filterPosts = makeWhitelistFilter(['post']);
            return pull(pull.values([opts.root]), pull.asyncMap(ssb.get.bind(ssb)), pull.map(rootToMsg), pull.asyncMap(rootToThread(ssb, threadMaxSize, filterPosts)));
        },
    };
}
module.exports = {
    name: 'threads',
    version: '2.0.0',
    manifest: {
        public: 'source',
        publicUpdates: 'source',
        profile: 'source',
        thread: 'source',
    },
    permissions: {
        master: {
            allow: ['public', 'profile', 'thread'],
        },
    },
    init: init,
};
//# sourceMappingURL=index.js.map