import { ViewStyle, ViewToken, StyleProp, ListRenderItem, VirtualizedListProperties } from 'react-native';
import { Component } from 'react';
export declare type Callback<T> = (endOrErr: boolean | any, data?: T) => void;
export declare type Readable<T> = (endOrErr: boolean | any, cb?: Callback<T>) => void;
export declare type GetReadable<T> = (opts?: any) => Readable<T>;
export interface PullFlatListProps<ItemT> extends VirtualizedListProperties<ItemT> {
    /**
     * Factory function which returns a pull stream to be used when scrolling
     * the FlatList, to pull more items and append them to the list.
     */
    getScrollStream: GetReadable<ItemT> | null;
    /**
     * Factory function which returns a pull stream to be used to prepend items
     * to the FlatList, regardless of scrolling.
     */
    getPrefixStream?: GetReadable<ItemT> | null;
    /**
     * How many items to pull from the pull stream when the scroll position
     * reaches the end.
     */
    pullAmount?: number;
    /**
     * Whether or not this list can be refreshed with the pull-to-refresh gesture.
     * By default, this is false.
     */
    refreshable?: boolean;
    /**
     * Rendered in between each item, but not at the top or bottom
     */
    ItemSeparatorComponent?: React.ComponentType<any> | (() => React.ReactElement<any>) | null;
    /**
     * Rendered when the list is empty.
     */
    ListEmptyComponent?: React.ComponentClass<any> | React.ReactElement<any> | (() => React.ReactElement<any>) | null;
    /**
     * Rendered at the very end of the list.
     */
    ListFooterComponent?: React.ComponentClass<any> | React.ReactElement<any> | (() => React.ReactElement<any>) | null;
    /**
     * Rendered at the very beginning of the list.
     */
    ListHeaderComponent?: React.ComponentClass<any> | React.ReactElement<any> | (() => React.ReactElement<any>) | null;
    /**
     * The colors (at least one) that will be used to draw the refresh indicator.
     */
    refreshColors?: Array<string>;
    /**
     * Optional custom style for multi-item rows generated when numColumns > 1
     */
    columnWrapperStyle?: StyleProp<ViewStyle>;
    /**
     * When false tapping outside of the focused text input when the keyboard
     * is up dismisses the keyboard. When true the scroll view will not catch
     * taps and the keyboard will not dismiss automatically. The default value
     * is false.
     */
    keyboardShouldPersistTaps?: boolean | 'always' | 'never' | 'handled';
    /**
     * `getItemLayout` is an optional optimization that lets us skip measurement of dynamic
     * content if you know the height of items a priori. getItemLayout is the most efficient,
     * and is easy to use if you have fixed height items, for example:
     * ```
     * getItemLayout={(data, index) => (
     *   {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}
     * )}
     * ```
     * Remember to include separator length (height or width) in your offset calculation if you specify
     * `ItemSeparatorComponent`.
     */
    getItemLayout?: (data: Array<ItemT> | null, index: number) => {
        length: number;
        offset: number;
        index: number;
    };
    /**
     * If true, renders items next to each other horizontally instead of stacked vertically.
     */
    horizontal?: boolean;
    /**
     * How many items to render in the initial batch
     */
    initialNumToRender?: number;
    /**
     * Instead of starting at the top with the first item, start at initialScrollIndex
     */
    initialScrollIndex?: number;
    /**
     * Used to extract a unique key for a given item at the specified index. Key is used for caching
     * and as the react key to track item re-ordering. The default extractor checks `item.key`, then
     * falls back to using the index, like React does.
     */
    keyExtractor?: (item: ItemT, index: number) => string;
    legacyImplementation?: boolean;
    /**
     * Multiple columns can only be rendered with `horizontal={false}` and will zig-zag like a `flexWrap` layout.
     * Items should all be the same height - masonry layouts are not supported.
     */
    numColumns?: number;
    /**
     * Called once when the scroll position gets within onEndReachedThreshold of the rendered content.
     */
    onEndReached?: ((info: {
        distanceFromEnd: number;
    }) => void) | null;
    /**
     * How far from the end (in units of visible length of the list) the bottom edge of the
     * list must be from the end of the content to trigger the `onEndReached` callback.
     * Thus a value of 0.5 will trigger `onEndReached` when the end of the content is
     * within half the visible length of the list.
     */
    onEndReachedThreshold?: number | null;
    /**
     * Called once when the PullFlatList has completed its first burst of pulls
     * of data. Emits the number of items in the data array.
     */
    onInitialPullDone?: (amountItems: number) => void;
    /**
     * Called when the viewability of rows changes, as defined by the `viewablePercentThreshold` prop.
     */
    onViewableItemsChanged?: ((info: {
        viewableItems: Array<ViewToken>;
        changed: Array<ViewToken>;
    }) => void) | null;
    /**
     * Takes an item from data and renders it into the list. Typical usage:
     * ```
     * _renderItem = ({item}) => (
     *   <TouchableOpacity onPress={() => this._onPress(item)}>
     *     <Text>{item.title}}</Text>
     *   <TouchableOpacity/>
     * );
     * ...
     * <FlatList data={[{title: 'Title Text', key: 'item1'}]} renderItem={this._renderItem} />
     * ```
     * Provides additional metadata like `index` if you need it.
     */
    renderItem: ListRenderItem<ItemT>;
    /**
     * See `ViewabilityHelper` for flow type and further documentation.
     */
    viewabilityConfig?: any;
    /**
     * Note: may have bugs (missing content) in some circumstances - use at your own risk.
     *
     * This may improve scroll performance for large lists.
     */
    removeClippedSubviews?: boolean;
}
export declare type State<T> = {
    data: Array<T>;
    isExpectingMore: boolean;
    updateInt: number;
    refreshing: boolean;
};
export declare class PullFlatList<T> extends Component<PullFlatListProps<T>, State<T>> {
    constructor(props: PullFlatListProps<T>);
    private scrollReadable?;
    private prefixReadable?;
    private isPulling;
    private morePullQueue;
    private iteration;
    private flatListRef?;
    private _onEndReached;
    private _onRefresh;
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentWillReceiveProps(nextProps: PullFlatListProps<T>): void;
    startScrollListener(readable?: Readable<T> | null): void;
    startPrefixListener(readable?: Readable<T> | null): void;
    stopScrollListener(): void;
    stopPrefixListener(): void;
    private onEndReached;
    private onRefresh;
    private _pullWhenScrolling;
    private _onEndPullingScroll;
    scrollToOffset(opts: any): void;
    forceRefresh(): void;
    render(): any;
}
export default PullFlatList;
