"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_native_1 = require("react-native");
const react_1 = require("react");
const pull = require('pull-stream');
const DEFAULT_INITIAL_PULL_AMOUNT = 4;
const DEFAULT_PULL_AMOUNT = 30;
const DEFAULT_END_THRESHOLD = 4;
class PullFlatList extends react_1.Component {
    constructor(props) {
        super(props);
        this.state = {
            data: [],
            isExpectingMore: true,
            updateInt: 0,
            refreshing: false,
        };
        this.isPulling = false;
        this.morePullQueue = 0;
        this.iteration = 0;
        this._onEndReached = this.onEndReached.bind(this);
        this._onRefresh = props.refreshable ? this.onRefresh.bind(this) : undefined;
        this.flatListRef = undefined;
    }
    componentDidMount() {
        if (this.props.getScrollStream) {
            this.startScrollListener(this.props.getScrollStream());
        }
        if (this.props.getPrefixStream) {
            this.startPrefixListener(this.props.getPrefixStream());
        }
    }
    componentWillUnmount() {
        this.stopScrollListener();
        this.stopPrefixListener();
    }
    componentWillReceiveProps(nextProps) {
        const nextReadable = nextProps.getScrollStream;
        if (nextReadable && nextReadable !== this.props.getScrollStream) {
            this.startScrollListener(nextReadable());
        }
    }
    startScrollListener(readable) {
        if (readable) {
            this.scrollReadable = readable;
        }
        if (this.state.isExpectingMore) {
            this._pullWhenScrolling(this.props.initialNumToRender || DEFAULT_INITIAL_PULL_AMOUNT);
        }
    }
    startPrefixListener(readable) {
        if (!readable) {
            return;
        }
        this.prefixReadable = readable;
        const that = this;
        readable(null, function read(end, item) {
            if (end) {
                return;
            }
            else if (item) {
                that.setState((prev) => ({
                    data: [item].concat(prev.data),
                    isExpectingMore: prev.isExpectingMore,
                    updateInt: 1 - prev.updateInt,
                    refreshing: prev.refreshing,
                }));
                readable(null, read);
            }
        });
    }
    stopScrollListener() {
        if (this.scrollReadable) {
            this.scrollReadable(true, () => { });
        }
        this.setState((prev) => ({
            data: [],
            isExpectingMore: true,
            updateInt: 1 - prev.updateInt,
            refreshing: prev.refreshing,
        }));
    }
    stopPrefixListener() {
        if (this.prefixReadable) {
            this.prefixReadable(true, () => { });
        }
    }
    onEndReached(info) {
        if (this.state.isExpectingMore) {
            this._pullWhenScrolling(this.props.pullAmount || DEFAULT_PULL_AMOUNT);
        }
    }
    onRefresh() {
        if (this.scrollReadable) {
            this.scrollReadable(true, () => { });
        }
        this.setState((prev) => ({
            data: [],
            isExpectingMore: true,
            updateInt: 1 - prev.updateInt,
            refreshing: true,
        }));
        this.iteration += 1;
        this.isPulling = false;
        this.morePullQueue = 0;
        if (this.props.getScrollStream) {
            this.scrollReadable = this.props.getScrollStream();
            this._pullWhenScrolling(this.props.initialNumToRender || DEFAULT_INITIAL_PULL_AMOUNT);
        }
        if (this.props.onRefresh) {
            this.props.onRefresh();
        }
    }
    _pullWhenScrolling(amount) {
        const readable = this.scrollReadable;
        if (!readable)
            return;
        if (this.isPulling) {
            this.morePullQueue = amount;
            return;
        }
        this.isPulling = true;
        const key = this.props.keyExtractor;
        const myIteration = this.iteration;
        const that = this;
        const buffer = [];
        readable(null, function read(end, item) {
            if (that.iteration !== myIteration)
                return;
            if (end === true) {
                that._onEndPullingScroll(buffer, false);
            }
            else if (item) {
                const idxStored = that.state.data.findIndex(x => key(x) === key(item));
                const idxInBuffer = buffer.findIndex(x => key(x) === key(item));
                // Consume message
                if (idxStored >= 0) {
                    const newData = that.state.data;
                    newData[idxStored] = item;
                    that.setState((prev) => ({
                        data: newData,
                        isExpectingMore: prev.isExpectingMore,
                        updateInt: 1 - prev.updateInt,
                        refreshing: prev.refreshing,
                    }));
                }
                else if (idxInBuffer >= 0) {
                    buffer[idxInBuffer] = item;
                }
                else {
                    buffer.push(item);
                }
                // Continue
                if (buffer.length >= amount) {
                    that._onEndPullingScroll(buffer, that.state.isExpectingMore);
                }
                else if (that.state.isExpectingMore) {
                    readable(null, read);
                }
            }
        });
    }
    _onEndPullingScroll(buffer, isExpectingMore) {
        this.isPulling = false;
        if (this.iteration === 0 && this.props.onInitialPullDone) {
            this.props.onInitialPullDone(this.state.data.length + buffer.length);
        }
        this.setState((prev) => ({
            data: prev.data.concat(buffer),
            isExpectingMore,
            updateInt: 1 - prev.updateInt,
            refreshing: false,
        }));
        const remaining = this.morePullQueue;
        if (remaining > 0) {
            this.morePullQueue = 0;
            this._pullWhenScrolling(remaining);
        }
    }
    scrollToOffset(opts) {
        if (this.flatListRef) {
            this.flatListRef.scrollToOffset(opts);
        }
    }
    forceRefresh() {
        this.onRefresh();
    }
    render() {
        const props = this.props;
        const state = this.state;
        const isEmpty = state.data.length === 0 &&
            !state.isExpectingMore &&
            !state.refreshing &&
            !this.isPulling;
        const ListFooterComponent = props.ListFooterComponent && state.isExpectingMore
            ? props.ListFooterComponent
            : isEmpty
                ? props.ListEmptyComponent
                : null;
        const isLoadingInitial = state.isExpectingMore && state.data.length === 0;
        return react_1.createElement(react_native_1.FlatList, Object.assign({ onEndReachedThreshold: DEFAULT_END_THRESHOLD }, props, { onRefresh: undefined, ListEmptyComponent: undefined, ref: (r) => {
                this.flatListRef = r;
            }, refreshControl: props.refreshable
                ? react_1.createElement(react_native_1.RefreshControl, {
                    colors: props.refreshColors || ['#000000'],
                    onRefresh: this._onRefresh,
                    progressViewOffset: props.progressViewOffset || undefined,
                    refreshing: state.refreshing || isLoadingInitial,
                })
                : undefined, data: state.data, extraData: state.updateInt, onEndReached: this._onEndReached, ListFooterComponent }));
    }
}
exports.PullFlatList = PullFlatList;
exports.default = PullFlatList;
//# sourceMappingURL=index.js.map